---
layout: post
title: redis缓存
categories: [缓存, redis]
description: 缓存问题
keywords: redis, 缓存穿透，缓存雪崩，缓存击穿
typora-root-url: ../../hailiangliu.github.io

---

[toc]

# Redis基础

帮助命令：

命令行： help @string; help @list

## 基本类型

### String

1. 字符串

   **场景：** 

   > 1.session
   >
   > 2.uuid
   >
   > 3.VFS in mem : 虚拟文件目录

   bit operation : 二进制操作：

   > 

2. 数值

   **场景：**

   > 1、限流器
   >
   > 2、统计
   >
   > 3、点击率

3. bitmap

   **场景：**

> ​	12306
>
> ​	二进制
>
> 登陆签到、活跃用户、 365天是365个bit  

### list

双向链表： 

- lpush+lpop可实现栈；
- rpush+rpop可实现队列；
- lindex 可实现数组

> 有序： 放入有序

### hash 

场景：

> 1、商品详情页
>
> 2、聚合场景

### set

集合。特点：去重、无序

 使用场景

> 抽奖，SRANDMEMBER   可返回不重复子集或可重复集合
>
> 推荐：共同好友（交集）、推荐好友（差集）

### zset(sorted set)

有序集合，去重+有序

使用场景：

> 1、评论+分页
>
> 2、排行榜 

TODO zset 数据结构



# 问题

## 1.1、缓存穿透

查询数据的时候，条件无法命中redis（数据根本不存在，如查询id=uuid的数据），每次查询都会打到后端数据库，此时缓存失效，低端攻击手段。

简单应对方法： 把入参条件为空的结果缓存，但不能无限制的缓存（缓存有爆）

升级版应对办法：1、在缓存层查询没有、DB查询之前，增加一层，这一层做一件事：根据某种算法高效的根据查询条件来决定需要不需要查询DB（有、没有）。高效的含义是空间、时间复杂度都比较低（尤其是空间）

```
布隆算法介绍：通过错误率换取空间的算法，是一种数据标识算法。  一个二进制数组（bit数组）+一个hash算法，结果又误差，返回存在实际情况可能不存在（由于hash碰撞导致）；返回不存在则一定不存在
布隆过滤器准去率的影响因素：
1、hash算法(hash函数的个数，多个hash函数可降低碰撞几率，只有3个hash函数的结果都一样并且数组对应位为1，才完全碰撞，有一个对不上，则不碰撞，因此碰撞几率是指数级别下降，缺点是数组长度需要成倍扩张（hash函数的倍数，一般是3-5个)
2、bit数组的长度（太小hash碰撞过高、太大空间浪费），但不管怎么说数据查询效率是O(1)
```

**实际使用场景：** 缓存的key，也就是查询的条件是有规则的，比如是id，那肯定是纯数字，非数字直接拒绝。

借助redis bitmap 实现布隆过滤器



## 1.2、缓存击穿 

是缓存穿透的一种特殊形式，指缓存的数据过期了，查询打到数据库。

```
一般情况下不需要解决，因为热点数据没有那么热
特殊场景：微博头条、排行榜之类；首先确定数据有多“热”
```



## 1.3、 缓存雪崩

1、cache中的大量数据同一时间都失效，请求瞬间打入数据库

2、缓存挂掉

影响数据库瞬间承受压力过载，数据库启动就被打垮。

> 解决办法：
>
>  1、缓存数据的有效期设置随机时间
>
> 2、缓存做集群



# 2、Redis集中集群方式

## 切片、主从复制

> 知识点：分片算法 一致性hash算法
>
> 概念：有一个数据环有2^32次方个点，假设有100台redis，按照hash算法映射到环中占100个节点，有数据存储时，key按同样hash算法找到映射为换种的位置，然后顺时针寻找redis，找到的第一个redis即为当前key要存储的reids服务。以此类推做存储。
>
> 优点：假设环中有10000台redis，新增1台时，只需要2台redis数据交互，剩下9999台不需要做数据通讯
>
> 缺点：数据倾斜；解决办法:增加虚拟节点（实际上redis内部是这么做的，虚拟了很多个曹位）



# 常见几种缓存更新策略 TODO

cache aside模式

