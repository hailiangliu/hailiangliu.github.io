layout: post
title: Java8特性
categories: [JAVA, 代码片段, java8]
description: some word here
keywords: java,代码技巧 

> java8学习记录 ： 学习课程 盛思园 （http://www.iprogramming.cn/jdk8.html）

# 第1讲：课程介绍

# 第2讲：课程介绍续

# 第3讲：Lambda表达式初步与函数式接口

> labbda： 函数式编程、匿名函数、闭包

# 第4讲：深入函数式接口与方法引用

> 函数式接口：
>
> 1、如果一个接口只有一个抽象方法，那么该接口就是一个函数式接口
>
> 2、如果我们在某个接口上声明了FunctionalInterface注解，那么编译器就会按照函数式接口的定义要求该接口
>
> 3、如果某个接口只有一个抽象方法，但我们并没有给该接口声明FunctionalInterface注解，那么编译器依旧会将该接口看做是函数式接口。

# 第5讲：Lambda表达式深入与流初步

```java
package com.demo.jdk8;

@FunctionalInterface
interface MyInterface {
    void test();

    String toString();
}

public class Test1 {
    public void myTest(MyInterface myInterface) {
        System.out.println(1);
        myInterface.test();
        System.out.println(2);
    }

    public static void main(String[] args) {
        Test1 test1 = new Test1();
        test1.myTest(() -> {
            System.out.println("my implements");
        });

        System.out.println("等价于以下");
        MyInterface myInterface = () -> {
            System.out.println("hello");
        };
        test1.myTest(myInterface);
        System.out.println(myInterface.getClass()); // class com.demo.jdk8.Test1$$Lambda$2/1747585824
        System.out.println(myInterface.getClass().getSuperclass());//class java.lang.Object
        System.out.println(myInterface.getClass().getInterfaces()[0]); //interface com.demo.jdk8.MyInterface
    }
}

```



```java
 		List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

        list.forEach((Integer i) -> {
            System.out.println( i*2);
        });
        // 可以简写，因为list类型固定，java编译时可以推断类型
        list.forEach( i ->{
            System.out.println(i*2);
        });
        // 继续简写, 只有一行可以省略括号
        list.forEach(i -> System.out.println(i*2));
        // 继续简写, 只有一个参数，通过静态引用简写
        list.forEach(System.out::println);
```



# 第6讲：Function接口详解

```java
		List<String> list = Arrays.asList("hello", "world", "hello world");
        //转换为大写
        list.forEach(item -> System.out.println(item.toUpperCase()));

        List<String> list2 = new ArrayList<>();
        list.forEach(item -> list2.add(item.toLowerCase()));

        list.stream().map(item -> item.toUpperCase()).forEach(item -> 				System.out.println(item));
        // 等价于 方法引用
        list.stream().map(String::toUpperCase).forEach(System.out::println);

        // 函数时编程得简化举例
        List<String> names = Arrays.asList("zhangsan", "lisi", "wangwu", "zhaoliu");
        //原始匿名内部类方式
        Collections.sort(names, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o2.compareTo(o1);
            }
        });
        // lambda 第一步
        Collections.sort(names,(String o1, String o2)->{
            return o2.compareTo(o1);
        }); 
        // 简写，省略类型, 一行方法体省略括号 省略return 
        Collections.sort(names,(o1,o2)->o2.compareTo(o1));
```

> 说明： map函数接收Function类型，可以定义一个Function
>
> ```java
>     /**
>      * Returns a stream consisting of the results of applying the given
>      * function to the elements of this stream.
>      *
>      * <p>This is an <a href="package-summary.html#StreamOps">intermediate
>      * operation</a>.
>      *
>      * @param <R> The element type of the new stream
>      * @param mapper a <a href="package-summary.html#NonInterference">non-interfering</a>,
>      *               <a href="package-summary.html#Statelessness">stateless</a>
>      *               function to apply to each element
>      * @return the new stream
>      */
>     <R> Stream<R> map(Function<? super T, ? extends R> mapper);
> ```
>
> `Function 为函数，有输入，有输出`
>
> ```java
> @FunctionalInterface
> public interface Function<T, R> {
> 
>     /**
>      * Applies this function to the given argument.
>      *
>      * @param t the function argument
>      * @return the function result
>      */
>     R apply(T t);
> ```
>
> 



# 第7讲：Function与BiFunction函数式接口详解

> Function函数中说明
>
> - apply：  应用函数（执行参数得行为）
>
> -  compose方法作用： 先应用参数得function，后应用this func
>
> - andThen函数，于compose相反
> - identify: 输入什么就返回什么
>
> ```java
> public class FunctionTest2 {
>     public static void main(String[] args) {
>         FunctionTest2 functionTest2 = new FunctionTest2();
> 
> 
>         // 输出12， 先计算function2即 2^2, 在执行function1即 4*3  = 12
>         System.out.println(functionTest2.compute(2, value -> value * 3, value -> value * value));
> 
>         // 输出36， 先计算function1即2*3=6， 再执行function1即6^6 =36
>         System.out.println(functionTest2.compute2(2, value -> value * 3, value -> value * value));
> 
>     }
> 
>     public int compute(int a, Function<Integer, Integer> function1, Function<Integer, Integer> functon2) {
>         return function1.compose(functon2).apply(a);
>     }
> 
>     public int compute2(int a, Function<Integer, Integer> funciton1, Function<Integer, Integer> function2) {
>         return funciton1.andThen(function2).apply(a);
>     }
> 
> }
> ```
>
> `Function 只接收一个参数，输入一个结果，如果输入两个参数呢？使用BiFunction`
>
> ```java
> System.out.println(functionTest2.compute3(1, 2, (v1, v2) -> v1 + v2)); // 输出 3
> System.out.println(functionTest2.compute3(1, 2, (v1, v2) -> v1 - v2)); // 输出 -1
> System.out.println(functionTest2.compute3(1, 2, (v1, v2) -> v1 * v2)); // 输出 2
> System.out.println(functionTest2.compute3(1, 2, (v1, v2) -> v1 / v2)); // 输出 0
> 
> // 使用BiFunction 传递四则运算
> public int compute3(int a, int b, BiFunction<Integer, Integer, Integer> function) {
>     return function.apply(a, b);
> }
> ```
>
> 

# 第8讲：BiFunction函数式接口实例演示

> 输入两个参数，返回一个结果， 
>
> 泛型中得三个参数得顺序分别是：输入的第一个参数类型、第二个参数类型，返回值类型

```java
  	// 找出符合条件得 结果集  条件： username=指定
 	public List<Person> getPersonByUsername(String username, List<Person> persons) {
        return persons.stream().filter(person -> person.getUsername().equalsIgnoreCase(username)).collect(Collectors.toList());
    }
    // 使用BiFunction 实现 查找age条件
    public List<Person> getPersonByAge(int age, List<Person> persons){
        BiFunction<Integer, List<Person>, List<Person>> function = (ageOfPerson, personList) ->{
            return personList.stream().filter(p->p.getAge()>ageOfPerson).collect(Collectors.toList());
        };
        return function.apply(age, persons);
    }
```

# 第9讲：Predicate函数式接口详解

> 输入一个参数，返回true/ false
>
> ```
> @FunctionalInterface
> public interface Predicate<T> {
> 
>     /**
>      * Evaluates this predicate on the given argument.
>      *
>      * @param t the input argument
>      * @return {@code true} if the input argument matches the predicate,
>      * otherwise {@code false}
>      */
>     boolean test(T t);
> ```

# 第10讲：Predicate深入剖析与函数式编程本质

> 略

# 第11讲：Supplier与函数式接口总结

```java

/**
 * Represents a supplier of results.
 *
 * <p>There is no requirement that a new or distinct result be returned each
 * time the supplier is invoked.
 *
 * <p>This is a <a href="package-summary.html">functional interface</a>
 * whose functional method is {@link #get()}.
 *
 * @param <T> the type of results supplied by this supplier
 *
 * @since 1.8
 */
@FunctionalInterface
public interface Supplier<T> {

    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}

```

> 说明：不接收任何参数，直接返回 一个结果
>
> ```java
> Supplier<String> supplier = () -> "hello world!";
> 
> Supplier<Student> studentSupplier = ()->new Student();
> studentSupplier.get().getAge(); // 获取一个
> 
>  Supplier<Student> studentSupplier1 = Student::new; // 简化写法，要求Studen类必须有一个无参构造方法（也可以有其他构造方法）
> 
> 
> ```
>
> 

# 第12讲：Optional深入详解

> 解决NPE问题
>
> ```java
>         Optional<String> optional1 = Optional.of("hello"); // 构造Optional对象， of函数内部会判断传入如果为空抛异常
>         // Optional<String> optional2 = Optional.ofNullable("hello"); // 构造Optional对象， 可接受null
> 
>         if(optional1.isPresent()){//如果存在则打印
>             System.out.println(optional1.get());  // 如果容器内为null，则抛异常，因此要做isPresenet判断
>         }
>         // 上面这种方式不建议，因为和 ==null的判断方式无本质区别
> 
>         // 官方建议使用函数式编程来实现
>         optional1.ifPresent((str)-> System.out.println(str)); //如果不为空直接执行，为空的话不执行此逻辑的
> 
>         // Optional内为空的话，填充一个(输入的参数）
>         System.out.println(optional1.orElse("world"));
>         // Optional内为空的话，填充一个(使用传入的Suppler生成
>         System.out.println(optional1.orElseGet(()->"niihao)"));
> ```
>
> 

# 第13讲：方法引用详解

> 特殊情况下的一种简写，是lambda的语法糖，有四类
>
> - 类名::静态方法名
> - 对象::实例方法名
> - 类名::实例方法名，前提：方法的第一个参数是被调用方法的调用者，第二个参数是被调用方法的参数
> - 类名::new
> - 类型[]::new 

# 第14讲：方法引用场景剖析与默认方法分析

>略

# 第15讲：Stream介绍与操作方式详解

> 流由3个部分组成
>
> - 源
> - 零个或多个中间操作
> - 终止操作
>
> 流操作的分类：
>
> - 惰性求值： 没有终止之前，中间的操作不执行
> - 及早求值：立刻求出结果

# 第16讲：Stream深度解析与源码实践

> ```java
> List<String> list = Arrays.asList("hello", "world", "helloworld");
> 
> Stream<String> stream = list.stream(); // list 转 stream
> 
> // stream 转 数组
> String[] result = stream.toArray(length -> new String[length]);
> String[] result1 = stream.toArray(String[]::new);
> 
> // stream 转list
> List<String> toList = stream.collect(Collectors.toList()); // Collector工具方法
> ArrayList<String> toList2 = stream.collect(() -> new ArrayList<String>(),
>                 (theList, item) -> theList.add(item), (list1, list2) -> list1.addAll(list2));
> // 改成静态引用
> LinkedList<String> toList3 = stream.collect(LinkedList::new, LinkedList::add, LinkedList::addAll);
> ```
>
> 

# 第17讲：Stream实例剖析

> 1. stream 转数组
>
>    ```java
>    String[] result = stream.toArray(length -> new String[length]);
>    String[] result1 = stream.toArray(String[]::new);
>    ```
>
> 2. stream 转list
>
>    ```java
>    List<String> toList = stream.collect(Collectors.toList()); // Collector工具方法
>    ArrayList<String> toList2 = stream.collect(() -> new ArrayList<String>(),
>            (theList, item) -> theList.add(item), (list1, list2) -> list1.addAll(list2));
>    // 改成静态引用
>    LinkedList<String> toList3 = stream.collect(LinkedList::new, LinkedList::add, LinkedList::addAll);
>    ```
>
> 3. stream 转 set
>
>    ```java
>    Set<String> set1 = stream.collect(Collectors.toSet());
>    Set<String> set2 = stream.collect(Collectors.toCollection(()->new TreeSet<String>()));
>    ```
>
> 4.  stream 合并拼接一个字符串
>
>    ```java
>    String str = stream.collect(Collectors.joining("-"));
>    ```
>
> 5.  全部转大写
>
>    ```java
>    stream.map(String::toUpperCase).collect(Collectors.toList()).forEach(System.out::println);
>    ```
>
> 6. flatMap， 扁平
>
>    ```java
>    Stream<List<Integer>> flatStream = Stream.of(Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6));
>    // 打散后 平方
>    flatStream.flatMap(theList -> theList.stream()).map(item->item*item).forEach(System.out::println);
>    ```
>
> 7.  生成流的用法
>
>    ```java
>    Stream<String> stream = Stream.generate(UUID.randomUUID()::toString);
>    //        System.out.println(stream.findFirst().get()); // findFirst返回optional, 直接get可能出npe，因此不可
>    stream.findFirst().ifPresent(System.out::println);// 建议写法
>    //   stream.findFirst().orElseThrow(Exception::new).;
>    
>    // 按规则，生成10个
>    Stream.iterate(1, item -> item + 2).limit(10);
>    ```
>
> 8.  找出流中大于2的元素，然后将每个元素诚意2，然后忽略掉流中的前两个元素，然后再取出流中的前两个元素，最后求出流中元素的综合
>
>    ```java
>    // 按规则，生成10个
>    Stream<Integer> streamInt = Stream.iterate(1, item -> item + 2).limit(10);
>    // 找出流中大于2的元素，然后将每个元素诚意2，然后忽略掉流中的前两个元素，然后再取出流中的前两个元素，最后求出流中元素的综合
>    System.out.println(streamInt.filter(i->i>2).mapToInt(i->i*2).skip(2).limit(2).sum()); // 32
>    // 如果需要同时求 sum，min max, 使用多个stream不合理，jdk内设置了
>    IntSummaryStatistics intSummaryStatistics = streamInt.filter(i -> i > 2).mapToInt(i -> i * 2).skip(2).limit(2).summaryStatistics();
>    intSummaryStatistics.getMax();
>    intSummaryStatistics.getMin();
>    intSummaryStatistics.getAverage(); 
>    ```
>
> 9.  惰性求值
>
>    ```java
>    // 什么都不输出，没有终止操作时，中间操作不会执行
>    list.stream().map(item->{
>        String result = item.substring(0,1).toUpperCase()+item.substring(1);
>        System.out.println("test");
>        return result;
>    });
>    ```
>
>    
>
> 10. 函数使用不当导致死循环
>
>     ```java
>     // 0 1 0 1 0 1 0 1的stream, 死循环， distinct会一直等待iterate结束
>     IntStream.iterate(0, i -> (i + 1) % 2).distinct().limit(6).forEach(System.out::println);
>     //调换函数顺序，先限制数量，后去重，则正常
>     IntStream.iterate(0, i -> (i + 1) % 2).limit(6).distinct().forEach(System.out::println);
>     ```
>
> 11. 
>
>     ``` java
>     
>     ```

第18讲：Stream陷阱剖析

第19讲：内部迭代与外部迭代本质剖析及流本源分析

第20讲：流的短路与并发流

第21讲：Stream分组与分区详解

第22讲：Collector源码分析与收集器核心

第23讲：Collector同一性与结合性分析

第24讲：Collector复合与注意事项

第25讲：收集器用法详解与多级分组和分区

第26讲：比较器详解与类型推断特例

第27讲：比较器深入

第28讲：自定义收集器实现

第29讲：自定义收集器深度剖析与并行流陷阱

第30讲：收集器枚举特性深度解析与并行流原理

第31讲：Collectors工厂类源码分析与实战

第32讲：groupingBy源码分析

第33讲：partioningBy与groupingByConcurrent源码分析

第34讲：Stream源码分析

第35讲：Stream与BaseStream源码分析

第36讲：分割迭代器源码剖析

第37讲：分割迭代器与ForkJoin详解

第38讲：分割迭代器实现分析

第39讲：OfPrimitive与OfInt实现原理剖析

第40讲：流源构造代码分析

第41讲：ReferencePipeline与AbstractPipeline源码深度解读

第42讲：IteratorSpliterator与流源操作方式详解

第43讲：流调用机制与原理大揭秘

第44讲：Sink与opWrapSink源码剖析

第45讲：TerminalOp源码分析与终止操作层次体系

第46讲：流延迟求值底层分析与Sink链接机制揭秘

第47讲：Stream中间操作与终止操作层次体系分析与设计思想剖析

第48讲：Joda项目介绍与实战

第49讲：Java 8全新日期和时间API详解与UTC介绍

第50讲：Java 8全新日期与时间API实战

第51讲：Java 8深入剖析与实战课程总结与展望

# 

